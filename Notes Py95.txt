iris = pd.read_csv('iris.txt',sep='\t')
iris.head()
setosa=iris.loc(iris.Turu=='setosa')
setosa.Canak_yaprak_boyu.plot.hist()

from scipy.stats import norm
MEAN, STD = 10, 25
print('MEAN: %.12f' % MEAN)
print(' STD: %.12f' % STD)
for i in range(-4, 5):
    a = norm.cdf(MEAN+i*STD, MEAN, STD)
    if i < 0:
        print('CDF(MEAN-%d*STD) : %.12f' % (abs(i), a))
    else:
        print('CDF(MEAN+%d*STD) : %.12f' % (i, a))
print('--------------------------')
L = np.random.normal(MEAN,STD,20000)
# N = len(L)
# for i in range(N):
#     print('L(%02d) : %f' % (i,L[i]))
Mean = np.mean(L)
print('Mean: %.12f' % Mean)
Std = np.std(L)
print(' Std: %.12f' % Std)
for i in range(-4, 5):
    a = norm.cdf(Mean+i*Std, Mean, Std)
    if i < 0:
        print('Cdf(Mean-%d*Std) : %.12f' % (abs(i), a))
    else:
        print('Cdf(Mean+%d*Std) : %.12f' % (i, a))
print('--------------------------')	

data = pd.read_csv(fName)

data.head()
data.head(10)
data.tail()
data.tail(10)

data.iloc[:,:-1]
data.shape
data.columns
data.isnull().sum()

correlation_matrix = data.corr()
plt.figure(figsize=(25,25))
heatmap(correlation_matrix, annot=True, cmap='rainbow')
plt.title('Correlation Heat Map')
plt.show()

import matplotlib.path as mpath
import matplotlib.patches as mpatches
fig, ax = plt.subplots()
Path = mpath.Path
path_data = [
    (Path.MOVETO, (1.58, -2.57)),
    (Path.CURVE4, (0.35, -1.1)),
    (Path.CURVE4, (-1.75, 2.0)),
    (Path.CURVE4, (0.375, 2.0)),
    (Path.LINETO, (0.85, 1.15)),
    (Path.CURVE4, (2.2, 3.2)),
    (Path.CURVE4, (3, 0.05)),
    (Path.CURVE4, (2.0, -0.5)),
    (Path.CLOSEPOLY, (1.58, -2.57)),
    ]
codes, verts = zip(*path_data)
path = mpath.Path(verts, codes)
patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)
ax.add_patch(patch)
x, y = zip(*path.vertices)
line, = ax.plot(x, y, 'go-')
ax.grid()
ax.axis('equal')
plt.show()

labels = 'Frogs', 'Hogs', 'Dogs', 'Logs'
sizes = [15, 30, 45, 10]
explode = (0, 0.1, 0, 0)
fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.axis('equal')
plt.show()

from matplotlib.widgets import Slider, Button, RadioButtons
fig, ax = plt.subplots()
plt.subplots_adjust(left=0.25, bottom=0.25)
t = np.arange(0.0, 1.0, 0.001)
a0 = 5
f0 = 3
delta_f = 5.0
s = a0 * np.sin(2 * np.pi * f0 * t)
l, = plt.plot(t, s, lw=2)
ax.margins(x=0)
axcolor = 'lightgoldenrodyellow'
axfreq = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor)
axamp = plt.axes([0.25, 0.15, 0.65, 0.03], facecolor=axcolor)
sfreq = Slider(axfreq, 'Freq', 0.1, 30.0, valinit=f0, valstep=delta_f)
samp = Slider(axamp, 'Amp', 0.1, 10.0, valinit=a0)
def update(val):
    amp = samp.val
    freq = sfreq.val
    l.set_ydata(amp*np.sin(2*np.pi*freq*t))
    fig.canvas.draw_idle()
sfreq.on_changed(update)
samp.on_changed(update)
resetax = plt.axes([0.8, 0.025, 0.1, 0.04])
button = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')
def reset(event):
    sfreq.reset()
    samp.reset()
button.on_clicked(reset)
rax = plt.axes([0.025, 0.5, 0.15, 0.15], facecolor=axcolor)
radio = RadioButtons(rax, ('red', 'blue', 'green'), active=0)
def colorfunc(label):
    l.set_color(label)
    fig.canvas.draw_idle()
radio.on_clicked(colorfunc)
# Initialize plot with correct initial active value
colorfunc(radio.value_selected)
plt.show()

def koch_snowflake(order, scale=10):
    def _koch_snowflake_complex(order):
        if order == 0:
            angles = np.array([0, 120, 240]) + 90
            return scale / np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)
        else:
            ZR = 0.5 - 0.5j * np.sqrt(3) / 3
            p1 = _koch_snowflake_complex(order - 1)  # start points
            p2 = np.roll(p1, shift=-1)  # end points
            dp = p2 - p1  # connection vectors
            new_points = np.empty(len(p1) * 4, dtype=np.complex128)
            new_points[::4] = p1
            new_points[1::4] = p1 + dp / 3
            new_points[2::4] = p1 + dp * ZR
            new_points[3::4] = p1 + dp / 3 * 2
            return new_points
    points = _koch_snowflake_complex(order)
    x, y = points.real, points.imag
    return x, y
x, y = koch_snowflake(order=4)
plt.figure(figsize=(8, 8))
plt.axis('equal')
plt.fill(x, y)
plt.show()
x, y = koch_snowflake(order=2)
fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(9, 3), subplot_kw={'aspect': 'equal'})
ax1.fill(x, y)
ax2.fill(x, y, facecolor='lightsalmon', edgecolor='orangered', linewidth=3)
ax3.fill(x, y, facecolor='none', edgecolor='purple', linewidth=3)
plt.show()

import itertools
import matplotlib.animation as animation
def data_gen():
    for cnt in itertools.count():
        t = cnt / 10
        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.)
def init():
    ax.set_ylim(-1.1, 1.1)
    ax.set_xlim(0, 10)
    del xdata[:]
    del ydata[:]
    line.set_data(xdata, ydata)
    return line,
fig, ax = plt.subplots()
line, = ax.plot([], [], lw=2)
ax.grid()
xdata, ydata = [], []
def run(data):
    # update the data
    t, y = data
    xdata.append(t)
    ydata.append(y)
    xmin, xmax = ax.get_xlim()
    if t >= xmax:
        ax.set_xlim(xmin, 2*xmax)
        ax.figure.canvas.draw()
    line.set_data(xdata, ydata)
    return line,
ani = animation.FuncAnimation(fig, run, data_gen, interval=10, init_func=init)
plt.show()

from numpy import sin, cos
import scipy.integrate as integrate
import matplotlib.animation as animation
G = 9.8  # acceleration due to gravity, in m/s^2
L1 = 1.0  # length of pendulum 1 in m
L2 = 1.0  # length of pendulum 2 in m
M1 = 1.0  # mass of pendulum 1 in kg
M2 = 1.0  # mass of pendulum 2 in kg
t_stop = 5  # how many seconds to simulate
def derivs(state, t):
    dydx = np.zeros_like(state)
    dydx[0] = state[1]
    delta = state[2] - state[0]
    den1 = (M1+M2) * L1 - M2 * L1 * cos(delta) * cos(delta)
    dydx[1] = ((M2 * L1 * state[1] * state[1] * sin(delta) * cos(delta)
                + M2 * G * sin(state[2]) * cos(delta)
                + M2 * L2 * state[3] * state[3] * sin(delta)
                - (M1+M2) * G * sin(state[0]))
               / den1)
    dydx[2] = state[3]
    den2 = (L2/L1) * den1
    dydx[3] = ((- M2 * L2 * state[3] * state[3] * sin(delta) * cos(delta)
                + (M1+M2) * G * sin(state[0]) * cos(delta)
                - (M1+M2) * L1 * state[1] * state[1] * sin(delta)
                - (M1+M2) * G * sin(state[2]))
               / den2)
    return dydx
# create a time array from 0..100 sampled at 0.05 second steps
dt = 0.05
t = np.arange(0, t_stop, dt)
# th1 and th2 are the initial angles (degrees)
# w10 and w20 are the initial angular velocities (degrees per second)
th1 = 120.0
w1 = 0.0
th2 = -10.0
w2 = 0.0
# initial state
state = np.radians([th1, w1, th2, w2])
# integrate your ODE using scipy.integrate.
y = integrate.odeint(derivs, state, t)
x1 = L1*sin(y[:, 0])
y1 = -L1*cos(y[:, 0])
x2 = L2*sin(y[:, 2]) + x1
y2 = -L2*cos(y[:, 2]) + y1
fig = plt.figure(figsize=(5, 4))
ax = fig.add_subplot(111, autoscale_on=False, xlim=(-2, 2), ylim=(-2, 1))
ax.set_aspect('equal')
ax.grid()
line, = ax.plot([], [], 'o-', lw=2)
time_template = 'time = %.1fs'
time_text = ax.text(0.05, 0.9, '', transform=ax.transAxes)
def animate(i):
    thisx = [0, x1[i], x2[i]]
    thisy = [0, y1[i], y2[i]]
    line.set_data(thisx, thisy)
    time_text.set_text(time_template % (i*dt))
    return line, time_text
ani = animation.FuncAnimation(fig, animate, len(y), interval=dt*1000, blit=True)
plt.show()

from matplotlib import colors
np.random.seed(19680801)
N_points = 100000
n_bins = 20
x = np.random.randn(N_points)
y = .4 * x + np.random.randn(100000) + 5
fig, axs = plt.subplots(1, 2, sharey=True, tight_layout=True)
axs[0].hist(x, bins=n_bins)
axs[1].hist(y, bins=n_bins)
fig, axs = plt.subplots(1, 3, figsize=(12, 5), sharex=True, sharey=True, tight_layout=True)
axs[0].hist2d(x, y, bins=40, norm=colors.LogNorm())
# We can increase the number of bins on each axis
axs[0].hist2d(x, y, bins=40)
# As well as define normalization of the colors
axs[1].hist2d(x, y, bins=40, norm=colors.LogNorm())
# We can also define custom numbers of bins for each axis
axs[2].hist2d(x, y, bins=(80, 10), norm=colors.LogNorm())
plt.show()

rg = np.random.default_rng(1)
# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2
mu, sigma = 2, 0.5
v = rg.normal(mu, sigma, 10000)
# Plot a normalized histogram with 50 bins
plt.hist(v, bins=50, density=True)       # matplotlib version (plot)
# Compute the histogram with numpy and then plot it
(n, bins) = np.histogram(v, bins=50, density=True)  # NumPy version (no plot)
plt.plot(.5 * (bins[1:] + bins[:-1]), n)
plt.show()

from scipy.stats import norm
MEAN, STD = 10, 25
print('MEAN: %.12f' % MEAN)
print(' STD: %.12f' % STD)
for i in range(-4, 5):
    a = norm.cdf(MEAN+i*STD, MEAN, STD)
    if i < 0:
        print('CDF(MEAN-%d*STD) : %.12f' % (abs(i), a))
    else:
        print('CDF(MEAN+%d*STD) : %.12f' % (i, a))
print('--------------------------')
L = np.random.normal(MEAN,STD,20000)
# N = len(L)
# for i in range(N):
#     print('L(%02d) : %f' % (i,L[i]))
Mean = np.mean(L)
print('Mean: %.12f' % Mean)
Std = np.std(L)
print(' Std: %.12f' % Std)
for i in range(-4, 5):
    a = norm.cdf(Mean+i*Std, Mean, Std)
    if i < 0:
        print('Cdf(Mean-%d*Std) : %.12f' % (abs(i), a))
    else:
        print('Cdf(Mean+%d*Std) : %.12f' % (i, a))
print('--------------------------')

fig, ax = plt.subplots()
plt.subplots_adjust(left=0.25, bottom=0.25)
t = np.arange(0.0, 1.0, 0.001)
a0 = 5
f0 = 3
delta_f = 5.0
s = a0 * np.sin(2 * np.pi * f0 * t)
l, = plt.plot(t, s, lw=2)
ax.margins(x=0)
axcolor = 'lightgoldenrodyellow'
axfreq = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor)
axamp = plt.axes([0.25, 0.15, 0.65, 0.03], facecolor=axcolor)
sfreq = Slider(axfreq, 'Freq', 0.1, 30.0, valinit=f0, valstep=delta_f)
samp = Slider(axamp, 'Amp', 0.1, 10.0, valinit=a0)
def update(val):
    amp = samp.val
    freq = sfreq.val
    l.set_ydata(amp*np.sin(2*np.pi*freq*t))
    fig.canvas.draw_idle()
sfreq.on_changed(update)
samp.on_changed(update)
resetax = plt.axes([0.8, 0.025, 0.1, 0.04])
button = Button(resetax, 'Reset', color=axcolor, hovercolor='0.975')
def reset(event):
    sfreq.reset()
    samp.reset()
button.on_clicked(reset)
rax = plt.axes([0.025, 0.5, 0.15, 0.15], facecolor=axcolor)
radio = RadioButtons(rax, ('red', 'blue', 'green'), active=0)
def colorfunc(label):
    l.set_color(label)
    fig.canvas.draw_idle()
radio.on_clicked(colorfunc)
plt.show()

def koch_snowflake(order, scale=10):
    """
    Return two lists x, y of point coordinates of the Koch snowflake.
    Arguments
    ---------
    order : int
        The recursion depth.
    scale : float
        The extent of the snowflake (edge length of the base triangle).
    """
    def _koch_snowflake_complex(order):
        if order == 0:
            # initial triangle
            angles = np.array([0, 120, 240]) + 90
            return scale / np.sqrt(3) * np.exp(np.deg2rad(angles) * 1j)
        else:
            ZR = 0.5 - 0.5j * np.sqrt(3) / 3
            p1 = _koch_snowflake_complex(order - 1)  # start points
            p2 = np.roll(p1, shift=-1)  # end points
            dp = p2 - p1  # connection vectors
            new_points = np.empty(len(p1) * 4, dtype=np.complex128)
            new_points[::4] = p1
            new_points[1::4] = p1 + dp / 3
            new_points[2::4] = p1 + dp * ZR
            new_points[3::4] = p1 + dp / 3 * 2
            return new_points
    points = _koch_snowflake_complex(order)
    x, y = points.real, points.imag
    return x, y
x, y = koch_snowflake(order=5)
plt.figure(figsize=(8, 8))
plt.axis('equal')
plt.plot(x, y)
# plt.fill(x, y)
plt.show()

import cv2
import numpy as np

Im = np.random.randint(0, 255, size=(400, 500, 3), dtype=np.uint8)
print(Im.shape, type(Im), sep='\n')
cv2.imshow('Display Window', Im)
cv2.waitKey(0)
cv2.destroyAllWindows()
cv2.imwrite('Temp1.jpg', Im)
cv2.imwrite('Temp2.jpg', Im, [cv2.IMWRITE_JPEG_QUALITY, 75])
cv2.imwrite('Temp3.png', Im)

Im1 = cv2.imread('../Pictures/Rsm15.jpg')
rate = 1.25
width = int(rate*Im1.shape[1])
height = int(rate*Im1.shape[0])
Im2 = cv2.resize(Im1, (width, height))
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm15.jpg')
Im2 = cv2.blur(Im1, (5, 5))
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
kernel = np.array([[1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1],
                   [1, 1, 1, 1, 1]])
kernel = kernel/sum(kernel)
Im2 = cv2.filter2D(Im1,-1,kernel)
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
kernel = np.array([[0.0, -1.0, 0.0],
                   [-1.0, 4.0, -1.0],
                   [0.0, -1.0, 0.0]])
Im2 = cv2.filter2D(Im1,-1,kernel)
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg', cv2.IMREAD_GRAYSCALE)
thresh = 128
Im2 = cv2.threshold(Im1, thresh, 255, cv2.THRESH_BINARY)[1]
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
Im2 = np.zeros(Im1.shape, dtype=np.uint8)
Im2[:, :, 2] = Im1[:, :, 2]
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
Im2 = Im1.copy()
Im2[:, :, 1] = np.zeros([Im2.shape[0], Im2.shape[1]])
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
Im2 = cv2.imread('../Pictures/Rsm02.jpg')
Im3 = cv2.resize(Im1, (600, 400))
Im4 = cv2.resize(Im2, (600, 400))
Im5 = cv2.addWeighted(Im3, 0.45, Im4, 0.45, 0.1)
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
print(Im3.shape, type(Im3))
print(Im4.shape, type(Im4))
print(Im5.shape, type(Im5))
cv2.imshow('Display Window', Im5)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm01.jpg')
Im2 = Im1.copy()
cv2.putText(Im2, "Python Examples", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255, 255), 3)
print(Im1.shape, type(Im1))
print(Im2.shape, type(Im2))
cv2.imshow('Display Window 1', Im1)
cv2.imshow('Display Window 2', Im2)
cv2.waitKey(0)
cv2.destroyAllWindows()

Im = cv2.imread('../Pictures/Rsm00.jpg')
if Im is None:
    exit('Could not read the image')
print(Im.dtype)
print(Im.size, 'byte')
a, b, c = Im.shape
print(a*b*c, 'byte')
print(Im.shape)
print(type(Im))
cv2.imshow('Display Window', Im)
if cv2.waitKey(0) == ord('s'):
    if cv2.imwrite('Temp.jpg', Im, [cv2.IMWRITE_JPEG_QUALITY, 75]):
        print('Image is successfully saved as file')
cv2.destroyAllWindows()

Im1 = cv2.imread('../Pictures/Rsm15.jpg')
e1 = cv2.getTickCount()
for i in range(3,29,2):
    print(i)
    Im2 = cv2.medianBlur(Im1,i)
e2 = cv2.getTickCount()
Sure = (e2 - e1)/cv2.getTickFrequency()
print('Süre : ', Sure, ' sn')

import cv2 as cv
cap = cv.VideoCapture(0)
while cap.isOpened():
    ret, frame = cap.read()
    frame = cv.flip(frame, 1)
    cv.imshow('Display Frame', frame)
    if cv.waitKey(1) & 0xFF == ord('q'):
        break
cap.release()
cv.destroyAllWindows()

import cv2 as cv
cap = cv.VideoCapture(0)
while cap.isOpened():
    ret, frame = cap.read()
    frame = cv.flip(frame, 1)
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
    cv.imshow('Display Frame', gray)
    if cv.waitKey(1) & 0xFF == ord('q'):
        break
cap.release()
cv.destroyAllWindows()

import cv2 as cv
cap = cv.VideoCapture(0)
fourcc = cv.VideoWriter_fourcc(*'XVID')
out = cv.VideoWriter('Temp.avi', fourcc, 60, (640,  480))
while cap.isOpened():
    ret, frame = cap.read()
    frame = cv.flip(frame, 1)
    cv.imshow('frame', frame)
    out.write(frame)
    if cv.waitKey(1) == ord('q'):
        break
cap.release()
out.release()
cv.destroyAllWindows()

import cv2 as cv
cap = cv.VideoCapture('Temp.avi')
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Can't receive frame")
        break
    cv.imshow('Display Frame', frame)
    if cv.waitKey(1) == ord('q'):
        break
cap.release()
cv.destroyAllWindows()

import numpy as np
import cv2 as cv
# mouse callback function
def draw_circle(event,x,y,flags,param):
    if event == cv.EVENT_LBUTTONDBLCLK:
        cv.circle(img,(x,y),100,(255,0,0),-1)
# Create a black image, a window and bind the function to window
img = np.zeros((512,512,3), np.uint8)
cv.namedWindow('image')
cv.setMouseCallback('image',draw_circle)
while(1):
    cv.imshow('image',img)
    if cv.waitKey(20) & 0xFF == 27:
        break
cv.destroyAllWindows()

import numpy as np
import cv2 as cv
drawing = False # true if mouse is pressed
mode = True # if True, draw rectangle. Press 'm' to toggle to curve
ix,iy = -1,-1
# mouse callback function
def draw_circle(event,x,y,flags,param):
    global ix,iy,drawing,mode
    if event == cv.EVENT_LBUTTONDOWN:
        drawing = True
        ix,iy = x,y
    elif event == cv.EVENT_MOUSEMOVE:
        if drawing == True:
            if mode == True:
                cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)
            else:
                cv.circle(img,(x,y),5,(0,0,255),-1)
    elif event == cv.EVENT_LBUTTONUP:
        drawing = False
        if mode == True:
            cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)
        else:
            cv.circle(img,(x,y),5,(0,0,255),-1)

img = np.zeros((512,512,3), np.uint8)
cv.namedWindow('image')
cv.setMouseCallback('image',draw_circle)
while(1):
    cv.imshow('image',img)
    k = cv.waitKey(1) & 0xFF
    if k == ord('m'):
        mode = not mode
    elif k == 27:
        break
cv.destroyAllWindows()

import numpy as np
import cv2 as cv
def nothing(x):
    pass
# Create a black image, a window
img = np.zeros((300,512,3), np.uint8)
cv.namedWindow('image')
# create trackbars for color change
cv.createTrackbar('R','image',0,255,nothing)
cv.createTrackbar('G','image',0,255,nothing)
cv.createTrackbar('B','image',0,255,nothing)
# create switch for ON/OFF functionality
switch = '0 : OFF \n1 : ON'
cv.createTrackbar(switch, 'image',0,1,nothing)
while(1):
    cv.imshow('image',img)
    k = cv.waitKey(1) & 0xFF
    if k == 27:
        break
    # get current positions of four trackbars
    r = cv.getTrackbarPos('R','image')
    g = cv.getTrackbarPos('G','image')
    b = cv.getTrackbarPos('B','image')
    s = cv.getTrackbarPos(switch,'image')
    if s == 0:
        img[:] = 0
    else:
        img[:] = [b,g,r]
cv.destroyAllWindows()

px = img[100,100]
px = img[100,100,0]
img[100,100] = [255,255,255]
img.item(10,10,2)
img.itemset((10,10,2),100)

a = img[280:340, 330:390]
img[273:333, 100:160] = a

b,g,r = cv.split(img)
img = cv.merge((b,g,r))
b = img[:,:,0]
img[:,:,2] = 0

import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt
BLUE = [255,0,0]
img1 = cv.imread('opencv-logo.png')
replicate = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REPLICATE)
reflect = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT)
reflect101 = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT_101)
wrap = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_WRAP)
constant= cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_CONSTANT,value=BLUE)
plt.subplot(231),plt.imshow(img1,'gray'),plt.title('ORIGINAL')
plt.subplot(232),plt.imshow(replicate,'gray'),plt.title('REPLICATE')
plt.subplot(233),plt.imshow(reflect,'gray'),plt.title('REFLECT')
plt.subplot(234),plt.imshow(reflect101,'gray'),plt.title('REFLECT_101')
plt.subplot(235),plt.imshow(wrap,'gray'),plt.title('WRAP')
plt.subplot(236),plt.imshow(constant,'gray'),plt.title('CONSTANT')
plt.show()

# Load two images
img1 = cv.imread('messi5.jpg')
img2 = cv.imread('opencv-logo-white.png')
# I want to put logo on top-left corner, So I create a ROI
rows,cols,channels = img2.shape
roi = img1[0:rows, 0:cols]
# Now create a mask of logo and create its inverse mask also
img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)
ret, mask = cv.threshold(img2gray, 10, 255, cv.THRESH_BINARY)
mask_inv = cv.bitwise_not(mask)
# Now black-out the area of logo in ROI
img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)
# Take only region of logo from logo image.
img2_fg = cv.bitwise_and(img2,img2,mask = mask)
# Put logo in ROI and modify the main image
dst = cv.add(img1_bg,img2_fg)
img1[0:rows, 0:cols ] = dst
cv.imshow('res',img1)
cv.waitKey(0)
cv.destroyAllWindows()

import cv2 as cv
import glob
fourcc = cv.VideoWriter_fourcc(*'XVID')
out = cv.VideoWriter('Temp.avi', fourcc, 5, (640,  480))
for filename in glob.glob('Pictures/*.jpg'):
    Im = cv.imread(filename)
    out.write(Im)
out.release()
print('Bitti')

import cv2 as cv
import numpy as np
fourcc = cv.VideoWriter_fourcc(*'XVID')
out = cv.VideoWriter('Temp.avi', fourcc, 16, (640,  480))
for i in range(0, 255):
    Im = i*np.ones((500, 500, 3), dtype=np.uint8)
    out.write(Im)
out.release()
print('Bitti')

img = np.zeros((512,512,3), np.uint8)
cv.line(img,(0,0),(511,511),(255,0,0),5)
cv.rectangle(img,(384,0),(510,128),(0,255,0),3)
cv.circle(img,(447,63), 63, (0,0,255), -1)
cv.ellipse(img,(256,256),(100,50),0,0,180,255,-1)
pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)
pts = pts.reshape((-1,1,2))
cv.polylines(img,[pts],True,(0,255,255))
font = cv.FONT_HERSHEY_SIMPLEX
cv.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv.LINE_AA)

x = np.uint8([250])
y = np.uint8([10])
print(x + y)
z = cv2.add(x,y)
print(z)

a = [i for i in dir(cv2)]
b = [i for i in dir(cv2) if 'EVENT' in i]
print(a, b, sep='\n\n')

Im = cv2.imread("../Pictures/Cars.jpg")
Scale = 0.00392
Blob = cv2.dnn.blobFromImage(Im, Scale, (416,416), (0,0,0), True, crop=False)
print(Im.shape)
print(Blob.shape)
Im.view()
Blob.view()

Im = np.full((400, 500, 3), 125, dtype=np.uint8)

import torch
a = torch.tensor([[1,2], [3,4], [5,6.]])
b = torch.full((3, 2), 42)
c = torch.cat((a,b))
d = torch.sin(c)
e = d.reshape(3, 2, 2)

# x = torch.tensor(4)
x = torch.tensor(5.)
x.type(), x.dtype

a = torch.tensor([[1, 2, 3], [4, 5, 6]])
b = a.t()
a.shape, b.shape

a = torch.tensor([[1, 2, 3],[4, 5, 6]])
a.type()
type(a)
a.dtype
a.size()
a.shape
b = a.type(torch.FloatTensor)
c = a.type(torch.DoubleTensor)
x = a.numpy()
y = torch.from_numpy(x)

a = torch.tensor([[1, 2, 3], [4, 5, 6]],dtype=torch.float16)

torch.cuda.is_available()

device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Using {device} device")
type(device)

a = torch.rand(4,7)
print(a)
print(f"Shape of tensor: {a.shape}")
print(f"Datatype of tensor: {a.dtype}")
print(f"Device tensor is stored on: {a.device}")
b = a.to("cpu")
a[0,0] = 5
b
id(a)==id(b)
id(b)

a = torch.rand(4,7)
a[:,1] = 0
a[1,:] = 0
print(a)
print('First row: ', a[0])
print('First column: ', a[:, 0])
print('Last column:', a[..., -1])

a = torch.ones(4,7)
a = a + 5;
a.add_(4)
b = a.sum()
c = b.item()
print(a)
print(b, type(b))
print(c, type(c))

a = torch.rand(3,5)
b = a * a
c = a ** 2
d = a.mul(a)
print(a,b,c,d,sep='\n')

a = torch.rand(3,7)
b = a @ a.T
c = a.matmul(a.T)
d = torch.zeros(3,3)
torch.matmul(a, a.T, out=d)
print(a,b,c,d,sep='\n')

a = torch.zeros(5)
b = torch.zeros(5,7)
c = b[0,:]
d = b[:,0]
print(a.shape,a,sep='\n')
print(b.shape,b,sep='\n')
print(c.shape,c,sep='\n')
print(d.shape,d,sep='\n')
a = torch.randn(3, 5, 50, 32)
print(a.shape)
print(a.dtype)

x = torch.rand(2,3)
y = torch.rand(2,3)
z1 = x*y
z2 = torch.mul(x,y)
z3 = x.mul(y)
print(x,y,z1,z2,z3,sep="\n")

z1 = 5*x
z2 = torch.mul(x,5)
z3 = x.mul(5)
print(x,z1,z2,z3,sep="\n")
x = torch.rand(2,4)
y = torch.rand(4,3)
z1 = torch.matmul(x,y)
z2 = x @ y
print(x,y,z1,z2,sep="\n")
print(torch.matmul,torch.mm,sep="\n")

x = torch.FloatTensor([1,3,5,9,4])
print(x)
y = x.numpy()
print(y)
z = torch.from_numpy(y)
print(z)
y[0]=100
print(x,y,z,sep='\n')
z[-1]=67.5
print(x,y,z,sep='\n')
z[2].item(), type(z[2].item())

x = torch.tensor(3.)
w = torch.tensor(4., requires_grad=True)
b = torch.tensor(5., requires_grad=True)
print('x:', x, '\nw:', w, '\nb:', b)
print(f'x: {x}\nw: {w}\nb: {b}')

y = w * x + b
y.backward()
print(y)
print('dy/dx:', x.grad)
print('dy/dw:', w.grad)
print('dy/db:', b.grad)

x = torch.tensor(10., requires_grad=True)
y = torch.tensor(20.)
print(x, x.requires_grad, sep='\n')
print(y, y.requires_grad, sep='\n')

z = 3*x + 2*y
z.backward()
print(z, z.requires_grad, sep='\n')
print('dz/dx:', x.grad)
print('dz/dy:', y.grad)

with torch.no_grad():
    z = 3*x + 2*y
print(z, z.requires_grad, sep='\n')
print('dz/dx:', x.grad)
print('dz/dy:', y.grad)

x = torch.randn(3, requires_grad=True)
print(x)
print(x.grad)
print(x.requires_grad)

x = torch.randn(2, 3, requires_grad = True)
y = torch.randn(2, 3, requires_grad = False)
z = torch.randn(2, 3, requires_grad = False)
print(x, x.requires_grad, sep="\n")
print(y, y.requires_grad, sep="\n")
print(z, z.requires_grad, sep="\n")
a = x + y + z
with torch.no_grad():
    b = x + y + z
print(a, a.requires_grad, sep="\n")
print(b, b.requires_grad, sep="\n")

a = torch.randn((3,3))
print(a)
a.requires_grad = True
print(a)

a = torch.randn((3,3), requires_grad = True)
b = torch.randn((3,3), requires_grad = True)
c = torch.randn((3,3), requires_grad = True)
d = (5 + 3*a - b*c).sum()
print(a.grad_fn,b.grad_fn,c.grad_fn,d.grad_fn,sep="\n")

d.backward()

print(a,b,c,sep="\n")

print(a.grad,b.grad,c.grad,sep="\n")

import torch
# Input (temp, rainfall, humidity)
x = torch.tensor([[73, 67, 43], [91, 88, 64], [87, 134, 58], [102, 43, 37], [69, 96, 70], [74, 66, 43],
                  [91, 87, 65], [88, 134, 59], [101, 44, 37], [68, 96, 71], [73, 66, 44], [92, 87, 64],
                  [87, 135, 57], [103, 43, 36], [68, 97, 70]], dtype=torch.float32)
# Targets (apples, oranges)
t = torch.tensor([[56, 70], [81, 101], [119, 133], [22, 37], [103, 119], [57, 69], [80, 102], [118, 132],
                  [21, 38], [104, 118], [57, 69], [82, 100], [118, 134], [20, 38], [102, 120]], dtype=torch.float32)
print(x.shape, t.shape, sep="\n")
w = torch.randn(2, 3, requires_grad=True)
b = torch.randn(2, requires_grad=True)
print(w, b, sep="\n")
lf = 1e-6
def model(x):
    return x @ w.t() + b
def mse(a, b):
    c = a - b
    return torch.sum(c * c) / c.numel()
y = model(x)
loss = mse(y, t)
print(t, y, loss, sep="\n")
print(w.grad, b.grad, sep="\n")
loss.backward() # Compute gradients
print(w.grad, b.grad, sep="\n")
w.grad.zero_()
b.grad.zero_()
print(w.grad, b.grad, sep="\n")
N = 10000
for n in range(N):
    y = model(x)
    loss = mse(y, t)
    if n % 1000 == 0:
        print(f"Ite = {n}, Loss = {loss}")
    loss.backward()
    with torch.no_grad():
        w -= lf*w.grad
        b -= lf*b.grad
        w.grad.zero_()
        b.grad.zero_()
y = model(x)
loss = mse(y, t)
print(f"Ite = {N}, Loss = {loss}")
print(loss, y, t, sep="\n")

import torch
from torch import nn
from torch.utils.data import DataLoader
from torchvision import datasets
from torchvision.transforms import ToTensor, Lambda, Compose
import matplotlib.pyplot as plt
import numpy as np
train_data = datasets.FashionMNIST(
    root="MyData",
    train=True,
    download=False,
    transform=ToTensor(),
)
test_data = datasets.FashionMNIST(
    root="MyData",
    train=False,
    download=False,
    transform=ToTensor(),
)
figure = plt.figure(figsize=(18, 5))
cols, rows = 6, 2
for i in range(1, cols * rows + 1):
    idx = torch.randint(len(train_data), size=(1,)).item()
    img, label = train_data[idx]
    figure.add_subplot(rows, cols, i)
    plt.title(train_data.classes[label])
    plt.axis("off")
    plt.imshow(img.squeeze(), cmap="gray")
plt.show()
batch_size = 100
train_dataloader = DataLoader(train_data, batch_size=batch_size)
test_dataloader = DataLoader(test_data, batch_size=batch_size)
len(train_dataloader.dataset)
len(train_dataloader)
type(train_dataloader)
type(train_data)
train_data.data.shape
train_dataloader.dataset.data.shape
train_data
train_data.classes
train_data.class_to_idx
test_data.targets
test_data
test_dataloader.dataset.data.max().item()
type(test_data[0][0])
type(test_data[0])
type(test_data)
test_data[0][0].max().item()
batch = 0
for X, y in test_dataloader:
    batch = batch + 1
    print(batch)
    print("Shape of X [N, C, H, W]:", X.shape)
    #print(X[0,0,:,:])
    print("Shape of y:", y.shape, y.dtype)
    break
 for batch, (X, y) in enumerate(test_dataloader,start=1):
        print("Batch:",batch)
        print("Shape of X [N, C, H, W]:", X.shape)
        print("Shape of y:", y.shape, y.dtype)
        break
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Using {device} device")
class NeuralNetwork(nn.Module):
    def __init__(self):
        super(NeuralNetwork, self).__init__()
        self.flatten = nn.Flatten()
        self.linear_relu_stack = nn.Sequential(
            nn.Linear(28*28, 50),
            nn.ReLU(),
            nn.Linear(50, 40),
            nn.ReLU(),
            nn.Linear(40, 10)
        )
    def forward(self, x):
        x = self.flatten(x)
        logits = self.linear_relu_stack(x)
        return logits
model = NeuralNetwork().to(device)
print(model)
loss_fn = nn.CrossEntropyLoss()
optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)
def train(dataloader, model, loss_fn, optimizer):
    size = len(dataloader.dataset)
    model.train()
    for batch, (X, y) in enumerate(dataloader):
        X, y = X.to(device), y.to(device)
        # Compute prediction error
        pred = model(X)
        loss = loss_fn(pred, y)
        # Backpropagation
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        if batch % 100 == 99:
            loss, current = loss.item(), (batch+1) * len(X)
            print(f"loss: {loss:>7f}  [{current:>5d}/{size:>5d}]")
def test(dataloader, model, loss_fn):
    size = len(dataloader.dataset)
    num_batches = len(dataloader)
    model.eval()
    test_loss, correct = 0, 0
    with torch.no_grad():
        for X, y in dataloader:
            X, y = X.to(device), y.to(device)
            pred = model(X)
            test_loss += loss_fn(pred, y).item()
            correct += (pred.argmax(1) == y).type(torch.float).sum().item()
    test_loss /= num_batches
    correct /= size
    print(f"Test Error: \n Accuracy: {(100*correct):>0.1f}%, Avg loss: {test_loss:>8f} \n")
epochs = 5
for t in range(epochs):
    print(f"Epoch {t+1}\n")
    train(train_dataloader, model, loss_fn, optimizer)
    test(test_dataloader, model, loss_fn)
print("Done!")
test(test_dataloader, model, loss_fn)
test(train_dataloader, model, loss_fn)
torch.save(model.state_dict(), "model.pth")
print("Saved PyTorch Model State to model.pth")
model = NeuralNetwork()
model.load_state_dict(torch.load("model.pth"))
classes = ["T-shirt/top","Trouser","Pullover","Dress","Coat","Sandal","Shirt","Sneaker","Bag","Ankle boot"]
classes
train_data.classes
test_data.classes
model.eval()
x, y = test_data[0][0], test_data[0][1]
with torch.no_grad():
    pred = model(x)
    predicted, actual = classes[pred[0].argmax(0)], classes[y]
    print(f'Predicted: "{predicted}", Actual: "{actual}"')

from numpy import vstack
from numpy import argmax
from sklearn.metrics import accuracy_score
from torchvision.datasets import MNIST
from torchvision.transforms import Compose
from torchvision.transforms import ToTensor
from torchvision.transforms import Normalize
from torch.utils.data import DataLoader
from torch.nn import Conv2d
from torch.nn import MaxPool2d
from torch.nn import Linear
from torch.nn import ReLU
from torch.nn import Softmax
from torch.nn import Module
from torch.optim import SGD
from torch.nn import CrossEntropyLoss
from torch.nn.init import kaiming_uniform_
from torch.nn.init import xavier_uniform_

# model definition
class CNN(Module):
    # define model elements
    def __init__(self, n_channels):
        super(CNN, self).__init__()
        # input to first hidden layer
        self.hidden1 = Conv2d(n_channels, 32, (3,3))
        kaiming_uniform_(self.hidden1.weight, nonlinearity='relu')
        self.act1 = ReLU()
        # first pooling layer
        self.pool1 = MaxPool2d((2,2), stride=(2,2))
        # second hidden layer
        self.hidden2 = Conv2d(32, 32, (3,3))
        kaiming_uniform_(self.hidden2.weight, nonlinearity='relu')
        self.act2 = ReLU()
        # second pooling layer
        self.pool2 = MaxPool2d((2,2), stride=(2,2))
        # fully connected layer
        self.hidden3 = Linear(5*5*32, 100)
        kaiming_uniform_(self.hidden3.weight, nonlinearity='relu')
        self.act3 = ReLU()
        # output layer
        self.hidden4 = Linear(100, 10)
        xavier_uniform_(self.hidden4.weight)
        self.act4 = Softmax(dim=1)

    # forward propagate input
    def forward(self, X):
        # input to first hidden layer
        X = self.hidden1(X)
        X = self.act1(X)
        X = self.pool1(X)
        # second hidden layer
        X = self.hidden2(X)
        X = self.act2(X)
        X = self.pool2(X)
        # flatten
        X = X.view(-1, 4*4*50)
        # third hidden layer
        X = self.hidden3(X)
        X = self.act3(X)
        # output layer
        X = self.hidden4(X)
        X = self.act4(X)
        return X

# prepare the dataset
def prepare_data(path):
    # define standardization
    trans = Compose([ToTensor(), Normalize((0.1307,), (0.3081,))])
    # load dataset
    train = MNIST(path, train=True, download=True, transform=trans)
    test = MNIST(path, train=False, download=True, transform=trans)
    # prepare data loaders
    train_dl = DataLoader(train, batch_size=64, shuffle=True)
    test_dl = DataLoader(test, batch_size=1024, shuffle=False)
    return train_dl, test_dl

# train the model
def train_model(train_dl, model):
    # define the optimization
    criterion = CrossEntropyLoss()
    optimizer = SGD(model.parameters(), lr=0.01, momentum=0.9)
    # enumerate epochs
    for epoch in range(10):
        # enumerate mini batches
        for i, (inputs, targets) in enumerate(train_dl):
            # clear the gradients
            optimizer.zero_grad()
            # compute the model output
            yhat = model(inputs)
            # calculate loss
            loss = criterion(yhat, targets)
            # credit assignment
            loss.backward()
            # update model weights
            optimizer.step()

# evaluate the model
def evaluate_model(test_dl, model):
    predictions, actuals = list(), list()
    for i, (inputs, targets) in enumerate(test_dl):
        # evaluate the model on the test set
        yhat = model(inputs)
        # retrieve numpy array
        yhat = yhat.detach().numpy()
        actual = targets.numpy()
        # convert to class labels
        yhat = argmax(yhat, axis=1)
        # reshape for stacking
        actual = actual.reshape((len(actual), 1))
        yhat = yhat.reshape((len(yhat), 1))
        # store
        predictions.append(yhat)
        actuals.append(actual)
    predictions, actuals = vstack(predictions), vstack(actuals)
    # calculate accuracy
    acc = accuracy_score(actuals, predictions)
    return acc

# prepare the data
path = '~/.torch/datasets/mnist'
train_dl, test_dl = prepare_data(path)
print(len(train_dl.dataset), len(test_dl.dataset))
# define the network
model = CNN(1)
# # train the model
train_model(train_dl, model)
# evaluate the model
acc = evaluate_model(test_dl, model)
print('Accuracy: %.3f' % acc)

from __future__ import print_function
import argparse
import torch
import torch.nn as nn
import torch.nn.functional as Func
import torch.optim as optim
from torchvision import datasets, transforms
from torch.optim.lr_scheduler import StepLR
class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, 3, 1)
        self.conv2 = nn.Conv2d(32, 64, 3, 1)
        self.dropout1 = nn.Dropout(0.25)
        self.dropout2 = nn.Dropout(0.5)
        self.fc1 = nn.Linear(9216, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = Func.relu(x)
        x = self.conv2(x)
        x = Func.relu(x)
        x = Func.max_pool2d(x, 2)
        x = self.dropout1(x)
        x = torch.flatten(x, 1)
        x = self.fc1(x)
        x = Func.relu(x)
        x = self.dropout2(x)
        x = self.fc2(x)
        output = Func.log_softmax(x, dim=1)
        return output


def train(args, model, device, train_loader, optimizer, epoch):
    model.train()
    for batch_idx, (data, target) in enumerate(train_loader):
        data, target = data.to(device), target.to(device)
        optimizer.zero_grad()
        output = model(data)
        loss = Func.nll_loss(output, target)
        loss.backward()
        optimizer.step()
        if batch_idx % args.log_interval == 0:
            print('Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'.format(
                epoch, batch_idx * len(data), len(train_loader.dataset),
                100. * batch_idx / len(train_loader), loss.item()))
            if args.dry_run:
                break


def test(model, device, test_loader):
    model.eval()
    test_loss = 0
    correct = 0
    with torch.no_grad():
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)
            output = model(data)
            test_loss += Func.nll_loss(output, target, reduction='sum').item()  # sum up batch loss
            pred = output.argmax(dim=1, keepdim=True)  # get the index of the max log-probability
            correct += pred.eq(target.view_as(pred)).sum().item()
    test_loss /= len(test_loader.dataset)
    print('\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\n'.format(
        test_loss, correct, len(test_loader.dataset),
        100. * correct / len(test_loader.dataset)))


parser = argparse.ArgumentParser(description='PyTorch MNIST Example')
parser.add_argument('--batch-size', type=int, default=64, metavar='N',
                    help='input batch size for training (default: 64)')
parser.add_argument('--test-batch-size', type=int, default=1000, metavar='N',
                    help='input batch size for testing (default: 1000)')
parser.add_argument('--epochs', type=int, default=14, metavar='N',
                    help='number of epochs to train (default: 14)')
parser.add_argument('--lr', type=float, default=1.0, metavar='LR',
                    help='learning rate (default: 1.0)')
parser.add_argument('--gamma', type=float, default=0.7, metavar='M',
                    help='Learning rate step gamma (default: 0.7)')
parser.add_argument('--no-cuda', action='store_true', default=False,
                    help='disables CUDA training')
parser.add_argument('--dry-run', action='store_true', default=False,
                    help='quickly check a single pass')
parser.add_argument('--seed', type=int, default=1, metavar='S',
                    help='random seed (default: 1)')
parser.add_argument('--log-interval', type=int, default=10, metavar='N',
                    help='how many batches to wait before logging training status')
parser.add_argument('--save-model', action='store_true', default=False,
                    help='For Saving the current Model')
args = parser.parse_args()
use_cuda = not args.no_cuda and torch.cuda.is_available()
torch.manual_seed(args.seed)
device = torch.device("cuda" if use_cuda else "cpu")
train_kwargs = {'batch_size': args.batch_size}
test_kwargs = {'batch_size': args.test_batch_size}
if use_cuda:
    cuda_kwargs = {'num_workers': 1,
                   'pin_memory': True,
                   'shuffle': True}
    train_kwargs.update(cuda_kwargs)
    test_kwargs.update(cuda_kwargs)

trans = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.1307,), (0.3081,))
    ])

path = '~/.torch/datasets/mnist'

dataset1 = datasets.MNIST(path, train=True, download=True, transform=trans)
dataset2 = datasets.MNIST(path, train=False, transform=trans)
train_loader = torch.utils.data.DataLoader(dataset1,**train_kwargs)
test_loader = torch.utils.data.DataLoader(dataset2, **test_kwargs)

model = Net().to(device)
optimizer = optim.Adadelta(model.parameters(), lr=args.lr)

scheduler = StepLR(optimizer, step_size=1, gamma=args.gamma)
for epoch in range(1, args.epochs + 1):
    train(args, model, device, train_loader, optimizer, epoch)
    test(model, device, test_loader)
    scheduler.step()

if args.save_model:
    torch.save(model.state_dict(), "mnist_cnn.pt")

from tkinter import *
import time

class App(Frame):
    def __init__(self,master=None):
        Frame.__init__(self, master)
        self.master = master
        self.label = Label(text="", fg="Red", font=("Helvetica", 18))
        self.label.place(x=50,y=80)
        self.update_clock()

    def update_clock(self):
        now = time.strftime("%H:%M:%S")
        self.label.configure(text=now)
        self.after(1000, self.update_clock)
root = Tk()
app=App(root)
root.wm_title("Tkinter clock")
root.geometry("200x200")
# root.after(1000, app.update_clock)
root.mainloop()

tk = Tk()
tk.title("Hasan TEMURTAŞ")
tk.geometry("800x600+300+100")
tk.state("normal")
tk.state("zoomed")
tk.state("iconic")
tk.wm_attributes("-alpha",0.8)

Bm = BitmapImage(data=BITMAP)
# bitmap = BitmapImage(file="bitmap.xbm")
Lbl = Image(tk,image=Bm)

L1 = Label(tk, text="First")
L2 = Label(tk, text="Second")
E1 = Entry(tk)
E2 = Entry(tk)
B1 = Button(tk, text="Okey")
B2 = Button(tk, text="Okey")
Cb = Checkbutton(tk, text="aaaaa")
L1.grid(sticky=E)
L2.grid(sticky=E)
E1.grid(row=0, column=1)
E2.grid(row=1, column=1)
Cb.grid(columnspan=2, sticky=W)
Lbl.grid(row=0, column=2, columnspan=2, rowspan=2,
               sticky=W+E+N+S, padx=5, pady=5)
B1.grid(row=2, column=2)
B2.grid(row=2, column=3)
tk.mainloop()

root = Tk()
listbox = Listbox(root)
listbox.pack(fill=BOTH, expand=1)
for i in range(20):
    listbox.insert(END, str(i))
mainloop()

yaz = Label(text="Merhaba Dünya", fg="blue", bg="red", font=("Open Sans","18","bold"))
yaz.pack()

fr1 = Frame(root)
fr1.pack()
fr2 = Frame(root)
fr2.pack(side=BOTTOM)
btn1 = Button(fr1,text='Buton 1',fg='red')
btn1.pack(side=LEFT)
btn2 = Button(fr1,text='Buton 2',fg='blue')
btn2.pack(side=LEFT)
btn3 = Button(fr1,text='Buton 3',fg='green')
btn3.pack(side=LEFT)
btn4 = Button(fr2,text='Buton 4',fg='purple')
btn4.pack()

s = tk.StringVar()
s.set("hello")

from tkinter import *

tk = Tk()
tk.title("Hasan")
tk.geometry("600x450+300+100")
# tk.state("normal")
# tk.state("zoomed")
# tk.state("iconic")
# tk.state("iconic")
# tk.wm_attributes("-alpha",0.8)
yaz = Label(text="Merhaba Dünya",
            fg="blue",
            bg="red",
            width = 15, height = 2, padx=5, pady=5,
            wraplength = 120, justify = "left",
            anchor="se",
            font=("Open Sans","18","bold"))
yaz.pack()

def AltProg():
    yaz["text"]="Hasan Temurtaş"
    yaz["bg"]="green"
    print("Hasan")
    btn2["state"]="active"

btn2 = Button(text="Pasif Buton", state="disabled")
btn2.pack()

btn = Button(text="Tıkla", command=AltProg)
btn.pack()
# btn.invoke()

def Kapat():
    quit()

btn3 = Button(text="Kapat", command=Kapat)
btn3.pack()

# veri = Entry(show="*")
veri = Entry()
veri.pack()
veri.insert(0,"deneme")

def VeriAl():
    yaz["text"] = veri.get()

btn3 = Button(text="Veri Al", command=VeriAl)
btn3.pack()

mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")

frm1 = Frame(root,width=50,height=400,bg="blue",relief=SUNKEN)
frm1.pack(side=LEFT)
frm2 = Frame(root,width=500,height=450,bg="green",relief=SUNKEN)
frm2.pack(side=RIGHT)

lbl1 = Label(frm2,font=("arial",50,"bold"),text="Hasan",bg="red")
lbl1.grid(row=1,column=0)
lbl1.pack()

root.mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")

lbl1 = Label(font=("arial",20,"bold"),text="Hasan",bg="green",fg="red")
lbl1.pack()
lbl2 = Label(font=("arial",20,"bold"),text="Hasan",bg="red",fg="green")
lbl2.pack(side=LEFT,fill=Y)
lbl3 = Label(font=("arial",20,"bold"),text="Hasan",bg="blue",fg="yellow")
lbl3.pack(side=TOP,fill=X)
root.mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")
label1 = Label(font=("arial",20,"bold"),text="Name")
label1.grid(row=0,sticky=E)
label2 = Label(font=("arial",20,"bold"),text="Password")
label2.grid(row=1,sticky=E)
entry1 = Entry(font=("arial",20,"bold"))
entry1.grid(row=0,column=1)
entry2 = Entry(font=("arial",20,"bold"))
entry2.grid(row=1,column=1)
cb1 = Checkbutton(font=("arial",20,"bold"),text="Hasan")
cb1.grid(columnspan=2)
root.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
lbl1 = Label(frm,text='Kullanıcı')
lbl2 = Label(frm,text='Şifre')
lbl1.grid(row=0,column=0,sticky=E)
lbl2.grid(row=1,column=0,sticky=E)
etr1 = Entry(frm)
etr2 = Entry(frm)
etr1.grid(row=0,column=1)
etr2.grid(row=1,column=1)
cbtn = Checkbutton(frm,text='Beni Hatırla')
cbtn.grid(columnspan=2)
btn = Button(frm,text='Tamam',command=bastir)
btn.grid(columnspan=3)
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
fr = Frame(frm,width=100,height=100)
frm.mainloop()

import tkinter
class CN:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.label1=tkinter.Label(self.main_window, text="Merhaba dünya")
        self.label2 = tkinter.Label(self.main_window, text="Bir ara verelim")
        self.label1.pack(side="right")
        self.label2.pack(side="top")
        tkinter.mainloop()
window=CN()

import tkinter
class MyGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.label = tkinter.Label(self.main_Window, text="Hello World")
        self.label.pack()
        tkinter.mainloop()
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class MyGUI:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.my_button = tkinter.Button(self.main_window, text='Click Me!', command=self.do_something)
        self.quit_button = tkinter.Button(self.main_window, text='Quit', command=self.main_window.destroy)
        self.my_button.pack()
        self.quit_button.pack()
        tkinter.mainloop()
    def do_something(self):
        tkinter.messagebox.showinfo('Response', 'Thanks for clicking the button')
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class KiloConverterGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a distance in Kilometers")
        self.kilo_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.kilo_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Convert", command=self.convert)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def convert(self):
        kilo = float(self.kilo_entry.get())
        miles = kilo * 0.6214
        tkinter.messagebox.showinfo('Result is', str(kilo) + 'kilometers is equal to ' + str(miles) + ' miles')
kilo_conv = KiloConverterGUI()

import tkinter
import tkinter.messagebox
def factrecursive(x):
    if x == 0:
        return 1
    else:
        return x * factrecursive(x - 1)
class factorialGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.int_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.int_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Compute Factorial", command=self.computeFactorial)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def computeFactorial(self):
        fact = factrecursive(int(self.int_entry.get()))
        tkinter.messagebox.showinfo('Result is', str(fact))
myFact = factorialGUI()

import tkinter
import tkinter.messagebox
def factorial(n):
    if n==0:
        return 1
    else:
        return n*factorial(n-1)
class factGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.fact_entry = tkinter.Entry(self.top_frame, width=5)
        self.prompt_label.pack(side="left")
        self.fact_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Calculate", command=self.factorial_call)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def factorial_call(self):
        number = int(self.fact_entry.get())
        if number >=0:
            result = factorial(number)
            tkinter.messagebox.showinfo('Result is', 'The factorial of ' + str(number) + ' is ' + str(result))
        else:
            tkinter.messagebox.showinfo('Error!', 'The number entered needs to be a non-negative integer')
factorialprogram = factGUI()

import tkinter
import tkinter.messagebox
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
def convert_to_mult(letter):
    if letter=='A1':
        return 4
    elif letter=='A2':
        return 3.75
    elif letter == 'A3':
        return 3.5
    elif letter=='B1':
        return 3.25
    elif letter=='B2':
        return 3
    elif letter=='B3':
        return 2.75
    elif letter=='C1':
        return 2.5
    elif letter=='C2':
        return 2.25
    elif letter=='C3':
        return 2
    elif letter=='D':
        return 1.5
    else:
        return 0
class gpaGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter your grade for EMU112 (8)")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter your grade for EMU102 (5)")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.calculate)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def calculate(self):
        g1 = self.x_entry.get()
        g2 = self.y_entry.get()
        g1n = convert_to_mult(g1)
        g2n = convert_to_mult(g2)
        gpa = (g1n*8 + g2n *5)/(8+5)
        tkinter.messagebox.showinfo('Result is', 'Your GPA is ' + str(gpa))
gpaprogram = gpaGUI()

from tkinter import *
frm = Tk()
fr1 = Frame(frm)
fr1.pack()
fr2 = Frame(frm)
fr2.pack(side=BOTTOM)
btn1 = Button(fr1,text='Buton 1',fg='red')
btn1.pack(side=LEFT)
btn2 = Button(fr1,text='Buton 2',fg='blue')
btn2.pack(side=LEFT)
btn3 = Button(fr1,text='Buton 3',fg='green')
btn3.pack(side=LEFT)
btn4 = Button(fr2,text='Buton 4',fg='purple')
btn4.pack()
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
lbl1 = Label(frm,text='Kullanıcı')
lbl2 = Label(frm,text='Şifre')
lbl1.grid(row=0,column=0,sticky=E)
lbl2.grid(row=1,column=0,sticky=E)
etr1 = Entry(frm)
etr2 = Entry(frm)
etr1.grid(row=0,column=1)
etr2.grid(row=1,column=1)
cbtn = Checkbutton(frm,text='Beni Hatırla')
cbtn.grid(columnspan=2)
btn = Button(frm,text='Tamam',command=bastir)
btn.grid(columnspan=3)
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
fr = Frame(frm,width=100,height=100)
frm.mainloop()

import tkinter
import tkinter.messagebox
def factrecursive(x):
    if x == 0:
        return 1
    else:
        return x * factrecursive(x - 1)
class factorialGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.int_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.int_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Compute Factorial", command=self.computeFactorial)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def computeFactorial(self):
        fact = factrecursive(int(self.int_entry.get()))
        tkinter.messagebox.showinfo('Result is', str(fact))
myFact = factorialGUI()

import tkinter
import tkinter.messagebox
def factorial(n):
    if n==0:
        return 1
    else:
        return n*factorial(n-1)
class factGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.fact_entry = tkinter.Entry(self.top_frame, width=5)
        self.prompt_label.pack(side="left")
        self.fact_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Calculate", command=self.factorial_call)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def factorial_call(self):
        number = int(self.fact_entry.get())
        if number >=0:
            result = factorial(number)
            tkinter.messagebox.showinfo('Result is', 'The factorial of ' + str(number) + ' is ' + str(result))
        else:
            tkinter.messagebox.showinfo('Error!', 'The number entered needs to be a non-negative integer')
factorialprogram = factGUI()

import tkinter
class CN:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.label1=tkinter.Label(self.main_window, text="Merhaba dünya")
        self.label2 = tkinter.Label(self.main_window, text="Bir ara verelim")
        self.label1.pack(side="right")
        self.label2.pack(side="top")
        tkinter.mainloop()
window=CN()

import tkinter
class MyGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.label = tkinter.Label(self.main_Window, text="Hello World")
        self.label.pack()
        tkinter.mainloop()
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class MyGUI:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.my_button = tkinter.Button(self.main_window, text='Click Me!', command=self.do_something)
        self.quit_button = tkinter.Button(self.main_window, text='Quit', command=self.main_window.destroy)
        self.my_button.pack()
        self.quit_button.pack()
        tkinter.mainloop()
    def do_something(self):
        tkinter.messagebox.showinfo('Response', 'Thanks for clicking the button')
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class KiloConverterGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a distance in Kilometers")
        self.kilo_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.kilo_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Convert", command=self.convert)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def convert(self):
        kilo = float(self.kilo_entry.get())
        miles = kilo * 0.6214
        tkinter.messagebox.showinfo('Result is', str(kilo) + 'kilometers is equal to ' + str(miles) + ' miles')
kilo_conv = KiloConverterGUI()

import tkinter
import tkinter.messagebox
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
import tkinter.font
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        menubar = tkinter.Menu(self.main_Window)
        # create a pulldown menu, and add it to the menu bar
        filemenu = tkinter.Menu(menubar, tearoff=0)
        filemenu.add_command(label="Open", font=("Cambria", 11, "bold"), command=self.hello)
        filemenu.add_command(label="Save", font=("Cambria", 11, "bold"), command=self.hello)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", font=("Cambria", 11, "bold"), command=self.main_Window.quit)
        menubar.add_cascade(label="File", font=("Cambria", 11, "bold"), menu=filemenu)
        # create more pulldown menus
        editmenu = tkinter.Menu(menubar, tearoff=0)
        editmenu.add_command(label="Cut", font=("Cambria", 11, "bold"), command=self.hello)
        editmenu.add_command(label="Copy", font=("Cambria", 11, "bold"), command=self.hello)
        editmenu.add_command(label="Paste", font=("Cambria", 11, "bold"), command=self.hello)
        menubar.add_cascade(label="Edit", font=("Cambria", 11, "bold"), menu=editmenu)
        helpmenu = tkinter.Menu(menubar, tearoff=0)
        helpmenu.add_command(label="About", font=("Cambria", 11, "bold"), command=self.hello)
        menubar.add_cascade(label="Help", font=("Cambria", 11, "bold"), menu=helpmenu)
        # display the menu
        self.main_Window.config(menu=menubar)
        self.main_Window.wm_title("GCD Calculator")
        self.main_Window.wm_minsize(width=400, height=200)
        self.main_Window.wm_maxsize(width=800, height=500)
        self.topframe = tkinter.Frame(self.main_Window)
        self.b1frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        self.b2frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        self.resultframe = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        #photo = tkinter.PhotoImage(file="euclid.gif")
        #self.giflabel = tkinter.Label(self.topframe, image=photo)
        #self.giflabel.image = photo  # keep a reference!
        #self.giflabel.pack()
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer", font=("Cambria", 16), fg="grey")
        self.x_entry = tkinter.Entry(self.b1frame, width=5, font=("Cambria", 20), fg="magenta", justify="right")
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer", font=("Cambria", 16), fg="grey")
        self.y_entry = tkinter.Entry(self.b2frame, width=5, font=("Cambria", 20), fg="magenta", justify = "right")
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call, font=("Cambria", 12, "bold"), fg="black",)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy, font=("Cambria", 12, "bold"), fg="black")
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.value=tkinter.StringVar()
        self.resultdescr=tkinter.Label(self.resultframe, text="The GCD is -->", font=("Cambria", 16), fg="grey")
        self.result_label=tkinter.Label(self.resultframe, textvariable=self.value, font=("Cambria", 20, "bold"), fg="red")
        self.resultdescr.pack(side="left")
        self.result_label.pack(side="left")
        self.topframe.pack()
        self.b1frame.pack()
        self.b2frame.pack()
        self.resultframe.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        self.value.set(result)
        # tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
    def hello(self):
        tkinter.messagebox.showinfo('Info!','Prepared for EMU112 Course')
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
def convert_to_mult(letter):
    if letter=='A1':
        return 4
    elif letter=='A2':
        return 3.75
    elif letter == 'A3':
        return 3.5
    elif letter=='B1':
        return 3.25
    elif letter=='B2':
        return 3
    elif letter=='B3':
        return 2.75
    elif letter=='C1':
        return 2.5
    elif letter=='C2':
        return 2.25
    elif letter=='C3':
        return 2
    elif letter=='D':
        return 1.5
    else:
        return 0
class gpaGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter your grade for EMU112 (8)")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter your grade for EMU102 (5)")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.calculate)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def calculate(self):
        g1 = self.x_entry.get()
        g2 = self.y_entry.get()
        g1n = convert_to_mult(g1)
        g2n = convert_to_mult(g2)
        gpa = (g1n*8 + g2n *5)/(8+5)
        tkinter.messagebox.showinfo('Result is', 'Your GPA is ' + str(gpa))
gpaprogram = gpaGUI()

__author__ = 'Peter'

import tkinter as tk
import tkinter.filedialog as tkf
import tkinter.font as tkfont
import tkinter.simpledialog as tkd
import sys
import random

alive = 0
sz = 12                                 # cell size for visualization
steps = 1000                              # run a number of steps
                            # milliseconds
step = 1
board, openfile = load_board_from_file('empty_board.gol')
#warp = 0
#warp = tk.IntVar()                                # warp around the edges ?
pauze = False                               # p = pauze status false at program start

root = tk.Tk()
root.title("Conway's Game of Life")
makemenu(root)
ui = tk.Frame(root, bg='white')                       # user interface
ui2 = tk.Frame(root, bg='white')
#      Define the user interaction widgets
MyCanvas = tk.Canvas(root, width=len(board[0])*sz + 1, height=len(board)*sz+1, highlightthickness=0, bd=0, bg='grey')
warp = tk.IntVar()                                # warp around the edges ?
showgrid = tk.IntVar()
# quitbutton = tk.Button(ui, text='QUIT', width=10, command=sys.exit)
startbutton = tk.Button(ui, text='START', width=10, command=lambda: life(from_startbutton=True))
pauzebutton = tk.Button(ui, text='PAUSE', width=10, command=lambda: checkpauze(p=True))
stepbutton = tk.Button(ui, text='STEP', width=10, command=lambda: life(from_stepbutton=True))
clearbutton = tk.Button(ui, text='CLEAR', width=10, command=clear)
# savebutton = tk.Button(ui, text='SAVE', width=10, command=lambda: save_board_to_file(board))
# loadbutton = tk.Button(ui, text='LOAD', width=10, command=load_board)
restartbutton = tk.Button(ui, text='RESET', width=10, command=lambda: load_board(openfile))
randombutton = tk.Button(ui, text='RANDOMIZE', width=10, command=rand_board)
statreport = tk.Label(root, text="      ", bg='white', justify=tk.LEFT, relief=tk.GROOVE,
                      font=tkfont.Font(weight='bold'))
speedcontrol = tk.Spinbox(ui2, width=5, values=(5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 1000))
speedcontrol_label = tk.Label(ui2, text='Delay between steps:', bg='white')
warpcontrol = tk.Checkbutton(ui2, text='Warp around edges? ', variable=warp, bg='white')
showgridcontrol = tk.Checkbutton(ui2, text='show grid? ', variable=showgrid, bg='white',
                                 command=lambda: display_board(board))
                                 # board must be redrawn, because toggle grid will not be shown before start is pressed
                                 # because display_board(board) sits inside life()
showgridcontrol.select()
# quitbutton.grid(row=0, column=0, padx=10, pady=10)
startbutton.grid(row=1, column=0, padx=10, pady=10)
pauzebutton.grid(row=2, column=0, padx=10, pady=10)
stepbutton.grid(row=3, column=0, padx=10, pady=10)
clearbutton.grid(row=4, column=0, padx=10, pady=10)
# savebutton.grid(row=5, column=0, padx=10, pady=10)
# loadbutton.grid(row=6, column=0, padx=10, pady=10)
restartbutton.grid(row=7, column=0, padx=10, pady=10)
randombutton.grid(row=8, column=0, padx=10, pady=10)
speedcontrol_label.grid(row=0, column=0, columnspan=2, padx=10, pady=5, sticky=tk.NW)
speedcontrol.grid(row=0, column=2, padx=10, pady=5, sticky=tk.NW)
warpcontrol.grid(row=1, column=3, columnspan=3, padx=10, ipadx=5, sticky=tk.NW)
showgridcontrol.grid(row=0, column=3, columnspan=2, padx=10, pady=5, ipadx=5, sticky=tk.NW)

#       Put everything on the screen
display_board(board)
MyCanvas.bind("<Button-1>", switch_cell)
ui.pack(side=tk.RIGHT, expand=tk.YES, fill=tk.BOTH)
MyCanvas.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
ui2.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH, anchor=tk.W)
statreport.pack(side=tk.RIGHT, expand=tk.NO, fill=tk.NONE)
root.mainloop()

from tkinter import *
import time
class App(Frame):
    def __init__(self,master=None):
        Frame.__init__(self, master)
        self.master = master
        self.label = Label(text="", fg="Red", font=("Helvetica", 18))
        self.label.place(x=50,y=80)
        self.update_clock()

    def update_clock(self):
        now = time.strftime("%H:%M:%S")
        self.label.configure(text=now)
        self.after(1000, self.update_clock)
root = Tk()
app=App(root)
root.wm_title("Tkinter clock")
root.geometry("200x200")
# root.after(1000, app.update_clock)
root.mainloop()

tk = Tk()
tk.title("Hasan TEMURTAŞ")
tk.geometry("800x600+300+100")
tk.state("normal")
tk.state("zoomed")
tk.state("iconic")
tk.wm_attributes("-alpha",0.8)

Bm = BitmapImage(data=BITMAP)
# bitmap = BitmapImage(file="bitmap.xbm")
Lbl = Image(tk,image=Bm)

L1 = Label(tk, text="First")
L2 = Label(tk, text="Second")
E1 = Entry(tk)
E2 = Entry(tk)
B1 = Button(tk, text="Okey")
B2 = Button(tk, text="Okey")
Cb = Checkbutton(tk, text="aaaaa")
L1.grid(sticky=E)
L2.grid(sticky=E)
E1.grid(row=0, column=1)
E2.grid(row=1, column=1)
Cb.grid(columnspan=2, sticky=W)
Lbl.grid(row=0, column=2, columnspan=2, rowspan=2,
               sticky=W+E+N+S, padx=5, pady=5)
B1.grid(row=2, column=2)
B2.grid(row=2, column=3)
tk.mainloop()

root = Tk()
listbox = Listbox(root)
listbox.pack(fill=BOTH, expand=1)
for i in range(20):
    listbox.insert(END, str(i))
mainloop()

yaz = Label(text="Merhaba Dünya", fg="blue", bg="red", font=("Open Sans","18","bold"))
yaz.pack()

fr1 = Frame(root)
fr1.pack()
fr2 = Frame(root)
fr2.pack(side=BOTTOM)
btn1 = Button(fr1,text='Buton 1',fg='red')
btn1.pack(side=LEFT)
btn2 = Button(fr1,text='Buton 2',fg='blue')
btn2.pack(side=LEFT)
btn3 = Button(fr1,text='Buton 3',fg='green')
btn3.pack(side=LEFT)
btn4 = Button(fr2,text='Buton 4',fg='purple')
btn4.pack()

s = tk.StringVar()
s.set("hello")

from tkinter import *

tk = Tk()
tk.title("Hasan")
tk.geometry("600x450+300+100")
# tk.state("normal")
# tk.state("zoomed")
# tk.state("iconic")
# tk.state("iconic")
# tk.wm_attributes("-alpha",0.8)
yaz = Label(text="Merhaba Dünya",
            fg="blue",
            bg="red",
            width = 15, height = 2, padx=5, pady=5,
            wraplength = 120, justify = "left",
            anchor="se",
            font=("Open Sans","18","bold"))
yaz.pack()

def AltProg():
    yaz["text"]="Hasan Temurtaş"
    yaz["bg"]="green"
    print("Hasan")
    btn2["state"]="active"

btn2 = Button(text="Pasif Buton", state="disabled")
btn2.pack()

btn = Button(text="Tıkla", command=AltProg)
btn.pack()
# btn.invoke()

def Kapat():
    quit()

btn3 = Button(text="Kapat", command=Kapat)
btn3.pack()

# veri = Entry(show="*")
veri = Entry()
veri.pack()
veri.insert(0,"deneme")

def VeriAl():
    yaz["text"] = veri.get()

btn3 = Button(text="Veri Al", command=VeriAl)
btn3.pack()

mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")

frm1 = Frame(root,width=50,height=400,bg="blue",relief=SUNKEN)
frm1.pack(side=LEFT)
frm2 = Frame(root,width=500,height=450,bg="green",relief=SUNKEN)
frm2.pack(side=RIGHT)

lbl1 = Label(frm2,font=("arial",50,"bold"),text="Hasan",bg="red")
lbl1.grid(row=1,column=0)
lbl1.pack()

root.mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")

lbl1 = Label(font=("arial",20,"bold"),text="Hasan",bg="green",fg="red")
lbl1.pack()
lbl2 = Label(font=("arial",20,"bold"),text="Hasan",bg="red",fg="green")
lbl2.pack(side=LEFT,fill=Y)
lbl3 = Label(font=("arial",20,"bold"),text="Hasan",bg="blue",fg="yellow")
lbl3.pack(side=TOP,fill=X)
root.mainloop()

from tkinter import *
root = Tk()
root.geometry("600x450+300+100")
root.title("Hasan TEMURTAŞ")
label1 = Label(font=("arial",20,"bold"),text="Name")
label1.grid(row=0,sticky=E)
label2 = Label(font=("arial",20,"bold"),text="Password")
label2.grid(row=1,sticky=E)
entry1 = Entry(font=("arial",20,"bold"))
entry1.grid(row=0,column=1)
entry2 = Entry(font=("arial",20,"bold"))
entry2.grid(row=1,column=1)
cb1 = Checkbutton(font=("arial",20,"bold"),text="Hasan")
cb1.grid(columnspan=2)
root.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
lbl1 = Label(frm,text='Kullanıcı')
lbl2 = Label(frm,text='Şifre')
lbl1.grid(row=0,column=0,sticky=E)
lbl2.grid(row=1,column=0,sticky=E)
etr1 = Entry(frm)
etr2 = Entry(frm)
etr1.grid(row=0,column=1)
etr2.grid(row=1,column=1)
cbtn = Checkbutton(frm,text='Beni Hatırla')
cbtn.grid(columnspan=2)
btn = Button(frm,text='Tamam',command=bastir)
btn.grid(columnspan=3)
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
fr = Frame(frm,width=100,height=100)
frm.mainloop()

import tkinter
class CN:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.label1=tkinter.Label(self.main_window, text="Merhaba dünya")
        self.label2 = tkinter.Label(self.main_window, text="Bir ara verelim")
        self.label1.pack(side="right")
        self.label2.pack(side="top")
        tkinter.mainloop()
window=CN()

import tkinter
class MyGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.label = tkinter.Label(self.main_Window, text="Hello World")
        self.label.pack()
        tkinter.mainloop()
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class MyGUI:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.my_button = tkinter.Button(self.main_window, text='Click Me!', command=self.do_something)
        self.quit_button = tkinter.Button(self.main_window, text='Quit', command=self.main_window.destroy)
        self.my_button.pack()
        self.quit_button.pack()
        tkinter.mainloop()
    def do_something(self):
        tkinter.messagebox.showinfo('Response', 'Thanks for clicking the button')
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class KiloConverterGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a distance in Kilometers")
        self.kilo_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.kilo_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Convert", command=self.convert)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def convert(self):
        kilo = float(self.kilo_entry.get())
        miles = kilo * 0.6214
        tkinter.messagebox.showinfo('Result is', str(kilo) + 'kilometers is equal to ' + str(miles) + ' miles')
kilo_conv = KiloConverterGUI()

import tkinter
import tkinter.messagebox
def factrecursive(x):
    if x == 0:
        return 1
    else:
        return x * factrecursive(x - 1)
class factorialGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.int_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.int_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Compute Factorial", command=self.computeFactorial)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def computeFactorial(self):
        fact = factrecursive(int(self.int_entry.get()))
        tkinter.messagebox.showinfo('Result is', str(fact))
myFact = factorialGUI()

import tkinter
import tkinter.messagebox
def factorial(n):
    if n==0:
        return 1
    else:
        return n*factorial(n-1)
class factGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.fact_entry = tkinter.Entry(self.top_frame, width=5)
        self.prompt_label.pack(side="left")
        self.fact_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Calculate", command=self.factorial_call)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def factorial_call(self):
        number = int(self.fact_entry.get())
        if number >=0:
            result = factorial(number)
            tkinter.messagebox.showinfo('Result is', 'The factorial of ' + str(number) + ' is ' + str(result))
        else:
            tkinter.messagebox.showinfo('Error!', 'The number entered needs to be a non-negative integer')
factorialprogram = factGUI()

import tkinter
import tkinter.messagebox
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
def convert_to_mult(letter):
    if letter=='A1':
        return 4
    elif letter=='A2':
        return 3.75
    elif letter == 'A3':
        return 3.5
    elif letter=='B1':
        return 3.25
    elif letter=='B2':
        return 3
    elif letter=='B3':
        return 2.75
    elif letter=='C1':
        return 2.5
    elif letter=='C2':
        return 2.25
    elif letter=='C3':
        return 2
    elif letter=='D':
        return 1.5
    else:
        return 0
class gpaGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter your grade for EMU112 (8)")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter your grade for EMU102 (5)")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.calculate)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def calculate(self):
        g1 = self.x_entry.get()
        g2 = self.y_entry.get()
        g1n = convert_to_mult(g1)
        g2n = convert_to_mult(g2)
        gpa = (g1n*8 + g2n *5)/(8+5)
        tkinter.messagebox.showinfo('Result is', 'Your GPA is ' + str(gpa))
gpaprogram = gpaGUI()

from tkinter import *
frm = Tk()
fr1 = Frame(frm)
fr1.pack()
fr2 = Frame(frm)
fr2.pack(side=BOTTOM)
btn1 = Button(fr1,text='Buton 1',fg='red')
btn1.pack(side=LEFT)
btn2 = Button(fr1,text='Buton 2',fg='blue')
btn2.pack(side=LEFT)
btn3 = Button(fr1,text='Buton 3',fg='green')
btn3.pack(side=LEFT)
btn4 = Button(fr2,text='Buton 4',fg='purple')
btn4.pack()
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
lbl1 = Label(frm,text='Kullanıcı')
lbl2 = Label(frm,text='Şifre')
lbl1.grid(row=0,column=0,sticky=E)
lbl2.grid(row=1,column=0,sticky=E)
etr1 = Entry(frm)
etr2 = Entry(frm)
etr1.grid(row=0,column=1)
etr2.grid(row=1,column=1)
cbtn = Checkbutton(frm,text='Beni Hatırla')
cbtn.grid(columnspan=2)
btn = Button(frm,text='Tamam',command=bastir)
btn.grid(columnspan=3)
frm.mainloop()

from tkinter import *
def bastir():
    print('Butona Basıldı')
frm = Tk()
fr = Frame(frm,width=100,height=100)
frm.mainloop()

import tkinter
import tkinter.messagebox
def factrecursive(x):
    if x == 0:
        return 1
    else:
        return x * factrecursive(x - 1)
class factorialGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.int_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.int_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Compute Factorial", command=self.computeFactorial)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def computeFactorial(self):
        fact = factrecursive(int(self.int_entry.get()))
        tkinter.messagebox.showinfo('Result is', str(fact))
myFact = factorialGUI()

import tkinter
import tkinter.messagebox
def factorial(n):
    if n==0:
        return 1
    else:
        return n*factorial(n-1)
class factGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a positive integer")
        self.fact_entry = tkinter.Entry(self.top_frame, width=5)
        self.prompt_label.pack(side="left")
        self.fact_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Calculate", command=self.factorial_call)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def factorial_call(self):
        number = int(self.fact_entry.get())
        if number >=0:
            result = factorial(number)
            tkinter.messagebox.showinfo('Result is', 'The factorial of ' + str(number) + ' is ' + str(result))
        else:
            tkinter.messagebox.showinfo('Error!', 'The number entered needs to be a non-negative integer')
factorialprogram = factGUI()

import tkinter
class CN:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.label1=tkinter.Label(self.main_window, text="Merhaba dünya")
        self.label2 = tkinter.Label(self.main_window, text="Bir ara verelim")
        self.label1.pack(side="right")
        self.label2.pack(side="top")
        tkinter.mainloop()
window=CN()

import tkinter
class MyGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.label = tkinter.Label(self.main_Window, text="Hello World")
        self.label.pack()
        tkinter.mainloop()
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class MyGUI:
    def __init__(self):
        self.main_window=tkinter.Tk()
        self.my_button = tkinter.Button(self.main_window, text='Click Me!', command=self.do_something)
        self.quit_button = tkinter.Button(self.main_window, text='Quit', command=self.main_window.destroy)
        self.my_button.pack()
        self.quit_button.pack()
        tkinter.mainloop()
    def do_something(self):
        tkinter.messagebox.showinfo('Response', 'Thanks for clicking the button')
my_gui = MyGUI()

import tkinter
import tkinter.messagebox
class KiloConverterGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.top_frame = tkinter.Frame(self.main_Window)
        self.bottom_frame = tkinter.Frame(self.main_Window)
        self.prompt_label = tkinter.Label(self.top_frame, text="Enter a distance in Kilometers")
        self.kilo_entry = tkinter.Entry(self.top_frame, width=10)
        self.prompt_label.pack(side="left")
        self.kilo_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.bottom_frame, text="Convert", command=self.convert)
        self.quit_button = tkinter.Button(self.bottom_frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.top_frame.pack()
        self.bottom_frame.pack()
        tkinter.mainloop()
    def convert(self):
        kilo = float(self.kilo_entry.get())
        miles = kilo * 0.6214
        tkinter.messagebox.showinfo('Result is', str(kilo) + 'kilometers is equal to ' + str(miles) + ' miles')
kilo_conv = KiloConverterGUI()

import tkinter
import tkinter.messagebox
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
import tkinter.font
def gcd(x,y):
    if x%y==0:
        return y
    else:
        return gcd(y,x%y)
class gcdGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        menubar = tkinter.Menu(self.main_Window)
        # create a pulldown menu, and add it to the menu bar
        filemenu = tkinter.Menu(menubar, tearoff=0)
        filemenu.add_command(label="Open", font=("Cambria", 11, "bold"), command=self.hello)
        filemenu.add_command(label="Save", font=("Cambria", 11, "bold"), command=self.hello)
        filemenu.add_separator()
        filemenu.add_command(label="Exit", font=("Cambria", 11, "bold"), command=self.main_Window.quit)
        menubar.add_cascade(label="File", font=("Cambria", 11, "bold"), menu=filemenu)
        # create more pulldown menus
        editmenu = tkinter.Menu(menubar, tearoff=0)
        editmenu.add_command(label="Cut", font=("Cambria", 11, "bold"), command=self.hello)
        editmenu.add_command(label="Copy", font=("Cambria", 11, "bold"), command=self.hello)
        editmenu.add_command(label="Paste", font=("Cambria", 11, "bold"), command=self.hello)
        menubar.add_cascade(label="Edit", font=("Cambria", 11, "bold"), menu=editmenu)
        helpmenu = tkinter.Menu(menubar, tearoff=0)
        helpmenu.add_command(label="About", font=("Cambria", 11, "bold"), command=self.hello)
        menubar.add_cascade(label="Help", font=("Cambria", 11, "bold"), menu=helpmenu)
        # display the menu
        self.main_Window.config(menu=menubar)
        self.main_Window.wm_title("GCD Calculator")
        self.main_Window.wm_minsize(width=400, height=200)
        self.main_Window.wm_maxsize(width=800, height=500)
        self.topframe = tkinter.Frame(self.main_Window)
        self.b1frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        self.b2frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        self.resultframe = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window, padx=10, pady=20)
        #photo = tkinter.PhotoImage(file="euclid.gif")
        #self.giflabel = tkinter.Label(self.topframe, image=photo)
        #self.giflabel.image = photo  # keep a reference!
        #self.giflabel.pack()
        self.x_label = tkinter.Label(self.b1frame, text="Enter a positive integer", font=("Cambria", 16), fg="grey")
        self.x_entry = tkinter.Entry(self.b1frame, width=5, font=("Cambria", 20), fg="magenta", justify="right")
        self.y_label = tkinter.Label(self.b2frame, text="Enter a positive integer", font=("Cambria", 16), fg="grey")
        self.y_entry = tkinter.Entry(self.b2frame, width=5, font=("Cambria", 20), fg="magenta", justify = "right")
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.gcd_call, font=("Cambria", 12, "bold"), fg="black",)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy, font=("Cambria", 12, "bold"), fg="black")
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.value=tkinter.StringVar()
        self.resultdescr=tkinter.Label(self.resultframe, text="The GCD is -->", font=("Cambria", 16), fg="grey")
        self.result_label=tkinter.Label(self.resultframe, textvariable=self.value, font=("Cambria", 20, "bold"), fg="red")
        self.resultdescr.pack(side="left")
        self.result_label.pack(side="left")
        self.topframe.pack()
        self.b1frame.pack()
        self.b2frame.pack()
        self.resultframe.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def gcd_call(self):
        number1 = int(self.x_entry.get())
        number2 = int(self.y_entry.get())
        result=gcd(number1,number2)
        self.value.set(result)
        # tkinter.messagebox.showinfo('Result is', 'The GCD of ' + str(number1) + ' and ' + str(number2) +' is ' + str(result))
    def hello(self):
        tkinter.messagebox.showinfo('Info!','Prepared for EMU112 Course')
gcdprogram = gcdGUI()

import tkinter
import tkinter.messagebox
def convert_to_mult(letter):
    if letter=='A1':
        return 4
    elif letter=='A2':
        return 3.75
    elif letter == 'A3':
        return 3.5
    elif letter=='B1':
        return 3.25
    elif letter=='B2':
        return 3
    elif letter=='B3':
        return 2.75
    elif letter=='C1':
        return 2.5
    elif letter=='C2':
        return 2.25
    elif letter=='C3':
        return 2
    elif letter=='D':
        return 1.5
    else:
        return 0
class gpaGUI:
    def __init__(self):
        self.main_Window = tkinter.Tk()
        self.b1frame = tkinter.Frame(self.main_Window)
        self.b2frame = tkinter.Frame(self.main_Window)
        self.b3frame = tkinter.Frame(self.main_Window)
        self.x_label = tkinter.Label(self.b1frame, text="Enter your grade for EMU112 (8)")
        self.x_entry = tkinter.Entry(self.b1frame, width=5)
        self.y_label = tkinter.Label(self.b2frame, text="Enter your grade for EMU102 (5)")
        self.y_entry = tkinter.Entry(self.b2frame, width=5)
        self.x_label.pack(side="left")
        self.x_entry.pack(side="left")
        self.y_label.pack(side="left")
        self.y_entry.pack(side="left")
        self.calc_button = tkinter.Button(self.b3frame, text="Calculate", command=self.calculate)
        self.quit_button = tkinter.Button(self.b3frame, text="Quit", command=self.main_Window.destroy)
        self.calc_button.pack(side="left")
        self.quit_button.pack(side="left")
        self.b1frame.pack()
        self.b2frame.pack()
        self.b3frame.pack()
        tkinter.mainloop()
    def calculate(self):
        g1 = self.x_entry.get()
        g2 = self.y_entry.get()
        g1n = convert_to_mult(g1)
        g2n = convert_to_mult(g2)
        gpa = (g1n*8 + g2n *5)/(8+5)
        tkinter.messagebox.showinfo('Result is', 'Your GPA is ' + str(gpa))
gpaprogram = gpaGUI()

__author__ = 'Peter'

import tkinter as tk
import tkinter.filedialog as tkf
import tkinter.font as tkfont
import tkinter.simpledialog as tkd
import sys
import random

def load_board_from_file(filename=None):
    if filename is None:
        filename = tkf.askopenfilename(defaultextension='.gol',
                                       filetypes=(('game of life files', '*.gol'), ('All files', '*.*')))
    board_f = open(filename, 'r')
    row = board_f.readline().strip('\n')
    y = 1
    bd = []
    while row != "":
        bd.append(list(row))
        y += 1
        row = board_f.readline().strip('\n')
    board_f.close()

    # TODO insert some tests here to check if the selected file meets the required file

    return bd, filename

def create_random_board(density):

    for row in range(len(board)):
        for col in range(len(board[0])):
            r = random.randrange(100)
            if r > density:
                board[row][col] = "."
            else:
                board[row][col] = "#"

def clear():
    global step
    rows = len(board)
    cols = len(board[0])
    for row in range(rows):
        for col in range(cols):
            board[row][col] = "."
    step = 0
    display_board(board)

def count_surrounding(row, col, bd):
    count = 0
    rows = len(bd)
    cols = len(bd[0])
    w = warp.get()
    for rr in range(row-1, row+2):
        if rr < 0:
            r = rows-1
        elif rr > rows-1:
            r = 0
        else:
            r = rr
        for cc in range(col-1, col+2):
            if cc < 0:
                c = cols-1
            elif cc > cols-1:
                c = 0
            else:
                c = cc
            if not (r == row and c == col):  # de cel in kwestie overslaan!
                if bd[r][c] == "#":
                    if not ((rr != r or cc != c) and w == 0):
                        count += 1
                    # if warping is off, then cells at the other side shouldn't be counted
    return count

def lifecycle(before):
    rows = len(before)
    cols = len(before[0])
    after = []
    for row in range(rows):         # initialize after
        after.append(list("."*cols))
    for row in range(rows):
        for col in range(cols):
            cs = count_surrounding(row, col, before)
            if before[row][col] == "#" and cs < 2:
                after[row][col] = "."
            elif before[row][col] == "#" and cs > 3:
                after[row][col] = "."
            elif before[row][col] == "." and cs == 3:
                after[row][col] = "#"
            else:
                after[row][col] = before[row][col]
    return after

def countliving():
    return str(alive)

def switch_cell(event):      # turn cell on or off with mouse click
    global alive
    cx = event.x
    cy = event.y
    bx = cx//sz
    by = cy//sz
    if bx < len(board[0]) and by < len(board):
        if board[by][bx] == ".":
            board[by][bx] = "#"
        else:
            board[by][bx] = "."
        display_board(board)


def display_board(bd):
    MyCanvas.delete(tk.ALL)
    cols = len(bd[0])
    rows = len(bd)
    counter = 0
    colors = ['grey', 'orange']
    ol_color = colors[showgrid.get()]
    for x in range(cols):
        for y in range(rows):
            rect = (x*sz, y*sz, (x+1)*sz, (y+1)*sz)
            if bd[y][x] == "#":
                MyCanvas.create_rectangle(rect, outline="black", fill="orange")
                counter += 1
            else:
                MyCanvas.create_rectangle(rect, outline=ol_color)
    stats = "living cells: " + str(counter) + "\n\ngeneration: " + str(step)
    MyCanvas.create_text((10, 10), text=stats, fill='white', anchor='nw', )  # show stats on canvas
    statreport.configure(text=stats)                                         # update stats in widget


def life(from_startbutton=False, from_stepbutton=False):
    global step
    global board
    global pauze
    global alive
    step += 1
    board = lifecycle(board)
    display_board(board)         # draw board and count living cells
    if from_startbutton is True:     # function has been called from start button and not from recursion (root.after...)
        pauze = False            # necessary for restart the startbutton is pressed after the pauzebutton
    checkpauze(pauze)
    if step <= steps and not pauze and not from_stepbutton:
        delay = speedcontrol.get()
        root.after(delay, life)  # root.after(delay, life()) is WRONG:  The function life needs to be passed as argument
                                 # life() will pass the result of life, i.e. execute it, before root.mainloop()

def checkpauze(p=False):
    global pauze
    pauze = p

def save_board_to_file(bd):
    filename = tkf.asksaveasfilename(defaultextension='.gol',
                                     filetypes=(('game of life files', '*.gol'), ('All files', '*.*')))
    if filename:
        f = open(filename, 'w')
        for row in range(len(bd)):
            f.write(''.join(board[row]) + '\n')
        f.close()

def load_board(file=None):      # filename passed when reopening (resetting) same file
    global board
    global step
    global openfile
    board = []
    board, openfile = load_board_from_file(file)
    step = 1
    display_board(board)

def rand_board():
    global board
    global step
    global openfile
    density = tkd.askinteger('Density', 'enter a cell density between 0 and 100')
    create_random_board(density)
    step = 1
    openfile = 'empty_board.gol'
    display_board(board)

def makemenu(win):
    top = tk.Menu(win)  # win=top-level window
    win.config(menu=top)  # set its menu option
    filemenu = tk.Menu(top)
    filemenu.add_command(label='Open...', command=load_board, underline=0)
    filemenu.add_command(label='Save...', command=lambda: save_board_to_file(board), underline=0)
    filemenu.add_command(label='Quit', command=sys.exit, underline=0)
    top.add_cascade(label='File', menu=filemenu, underline=0)
    edit = tk.Menu(top, tearoff=False)
    edit.add_command(label='Clear', command=clear, underline=0)
    edit.add_command(label='Randomize', command=rand_board, underline=0)
    edit.add_separator()
    top.add_cascade(label='Edit', menu=edit, underline=0)

#########  main program ###########

alive = 0
sz = 12                                 # cell size for visualization
steps = 1000                              # run a number of steps
                            # milliseconds
step = 1
board, openfile = load_board_from_file('empty_board.gol')
#warp = 0
#warp = tk.IntVar()                                # warp around the edges ?
pauze = False                               # p = pauze status false at program start

root = tk.Tk()
root.title("Conway's Game of Life")
makemenu(root)
ui = tk.Frame(root, bg='white')                       # user interface
ui2 = tk.Frame(root, bg='white')
#      Define the user interaction widgets
MyCanvas = tk.Canvas(root, width=len(board[0])*sz + 1, height=len(board)*sz+1, highlightthickness=0, bd=0, bg='grey')
warp = tk.IntVar()                                # warp around the edges ?
showgrid = tk.IntVar()
# quitbutton = tk.Button(ui, text='QUIT', width=10, command=sys.exit)
startbutton = tk.Button(ui, text='START', width=10, command=lambda: life(from_startbutton=True))
pauzebutton = tk.Button(ui, text='PAUSE', width=10, command=lambda: checkpauze(p=True))
stepbutton = tk.Button(ui, text='STEP', width=10, command=lambda: life(from_stepbutton=True))
clearbutton = tk.Button(ui, text='CLEAR', width=10, command=clear)
# savebutton = tk.Button(ui, text='SAVE', width=10, command=lambda: save_board_to_file(board))
# loadbutton = tk.Button(ui, text='LOAD', width=10, command=load_board)
restartbutton = tk.Button(ui, text='RESET', width=10, command=lambda: load_board(openfile))
randombutton = tk.Button(ui, text='RANDOMIZE', width=10, command=rand_board)
statreport = tk.Label(root, text="      ", bg='white', justify=tk.LEFT, relief=tk.GROOVE,
                      font=tkfont.Font(weight='bold'))
speedcontrol = tk.Spinbox(ui2, width=5, values=(5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, 300, 400, 500, 1000))
speedcontrol_label = tk.Label(ui2, text='Delay between steps:', bg='white')
warpcontrol = tk.Checkbutton(ui2, text='Warp around edges? ', variable=warp, bg='white')
showgridcontrol = tk.Checkbutton(ui2, text='show grid? ', variable=showgrid, bg='white',
                                 command=lambda: display_board(board))
                                 # board must be redrawn, because toggle grid will not be shown before start is pressed
                                 # because display_board(board) sits inside life()
showgridcontrol.select()
# quitbutton.grid(row=0, column=0, padx=10, pady=10)
startbutton.grid(row=1, column=0, padx=10, pady=10)
pauzebutton.grid(row=2, column=0, padx=10, pady=10)
stepbutton.grid(row=3, column=0, padx=10, pady=10)
clearbutton.grid(row=4, column=0, padx=10, pady=10)
# savebutton.grid(row=5, column=0, padx=10, pady=10)
# loadbutton.grid(row=6, column=0, padx=10, pady=10)
restartbutton.grid(row=7, column=0, padx=10, pady=10)
randombutton.grid(row=8, column=0, padx=10, pady=10)
speedcontrol_label.grid(row=0, column=0, columnspan=2, padx=10, pady=5, sticky=tk.NW)
speedcontrol.grid(row=0, column=2, padx=10, pady=5, sticky=tk.NW)
warpcontrol.grid(row=1, column=3, columnspan=3, padx=10, ipadx=5, sticky=tk.NW)
showgridcontrol.grid(row=0, column=3, columnspan=2, padx=10, pady=5, ipadx=5, sticky=tk.NW)

#       Put everything on the screen
display_board(board)
MyCanvas.bind("<Button-1>", switch_cell)
ui.pack(side=tk.RIGHT, expand=tk.YES, fill=tk.BOTH)
MyCanvas.pack(side=tk.TOP, expand=tk.YES, fill=tk.BOTH)
ui2.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH, anchor=tk.W)
statreport.pack(side=tk.RIGHT, expand=tk.NO, fill=tk.NONE)
root.mainloop()

Wb = Model.get_weights()
n = len(Wb) // 2
for i in range(n):
    m = 2*i
    print(f"W{i:<3} : {Wb[m].shape}")
    print(f"b{i:<3} : {Wb[m+1].shape}")
# Model.set_weights(Wb)

def ResetWeights(Model):
    for Layer in Model.layers:
        if hasattr(Layer, 'kernel_initializer') and hasattr(Layer, 'bias_initializer'):
            weights, biases = Layer.get_weights()
            Layer.set_weights([Layer.kernel_initializer(shape=weights.shape), Layer.bias_initializer(shape=biases.shape)])
            print(weights.shape, biases.shape)

ResetWeights(Model)

Wb = Model.get_weights()
print(Wb[8][0,:],Wb[9],sep="\n")

test_idx = [0, 50, 100]
train_target = np.delete(iris.target, test_idx)
train_data = np.delete(iris.data, test_idx, axis=0)
test_target = iris.target[test_idx]
test_data = iris.data[test_idx]
test_data

Boyut = 3 # 1 veya 3
if Boyut == 1:
    XTrain = np.dot(XTrain, (0.2989, 0.587, 0.114)).astype("uint8")
    XTest = np.dot(XTest, (0.2989, 0.587, 0.114)).astype("uint8")
    XTrain = np.expand_dims(XTrain, axis=3)
    XTest = np.expand_dims(XTest, axis=3)

losses = {
    "autoencoder": "mse",
    "classification": "categorical_crossentropy"
}
loss_weights = {
    "autoencoder": 1.0,
    "classification": 5.0
}
metrics = {
    "autoencoder": "mse",
    "classification": "acc"
}
Model.compile(optimizer="adam", loss=losses, loss_weights=loss_weights, metrics=metrics)

yPredict = Model.predict(xTest)
print(yPredict,yPredict.shape,sep="\n")

Wb = Model.get_weights()
n = len(Wb)
print(n)
for i in range(n):
    print(Wb[i].shape)
# Model.set_weights(Wb)

def ResetWeights(Model):
    for Layer in Model.layers:
        if hasattr(Layer, 'kernel_initializer') and hasattr(Layer, 'bias_initializer'):
            weights, biases = Layer.get_weights()
            print(weights.shape, biases.shape)
            Layer.set_weights([Layer.kernel_initializer(shape=weights.shape), Layer.bias_initializer(shape=biases.shape)])
ResetWeights(Model)
Model.layers
Model.layers[1].get_weights()
Model.metrics_names

Name = Names[5][0]
Im1 = io.imread(Name)
Im2 = image.imread(Name)
Im3 = (255*Im2).astype(np.uint8)
print(Im1.dtype,Im2.dtype,Im3.dtype)
print(Im1.max(),Im2.max(),Im3.max())

a = transform.rescale(Im1[:,:,0], Rate, anti_aliasing=False)
b = transform.rescale(Im1[:,:,1], Rate, anti_aliasing=False)
c = transform.rescale(Im1[:,:,2], Rate, anti_aliasing=False)
